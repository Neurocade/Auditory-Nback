
<!--
File: nback.html
Purpose: Auditory N‑Back task with 4 conditions (letters/tones ± visual distractor),
         N‑back & ISI selectors, Instructions page, Voice Settings page (TTS with persistence & test),
         fixation cross under title, Back buttons, MATCH flash, correct RT/indexing,
         and ***controlled target scheduling*** with evenness guardrails.

WHAT’S INCLUDED
- 4 Conditions:
  (1) Letters (spoken), (2) Sounds (tones), (3) Letters + visual distractor, (4) Sounds + visual distractor.
- N‑back selector (1–3).
- ISI selector (1000–3000 ms).
- Fixation cross under the title (2× size); hides only during distractors in Cond 3/4’s stimulus window.
- MATCH button with flash feedback; Space/Enter support (scoped to the button).
- Back to Menu; safe cleanup of timers and TTS.
- Instructions page (per‑condition guidance); Back to Home.
- Voice Settings page (TTS voice/rate/pitch/volume), settings persisted via localStorage, with “Test voice”.
- ***NEW*** Controlled sequence generator:
  • Typical target ratio ≈30% (literature‑typical), overrideable (e.g., 30% ≈ 12/40),
  • ~15% of *trials* involved in 2–4‑in‑a‑row streaks (bounded, spaced, and capped),
  • ≥1 long no‑target span (8–10) per block,
  • Per‑window quotas to distribute targets more evenly across the block.

NOTES
- To force ~12 matches in 40: set TARGET_POLICY.overrideRatio = 0.30.
- If constraints are tight on a random draw, the generator relaxes soft constraints (spacing/tolerance) before touching streak caps.

-->

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Auditory N-Back Task</title>
<style>
:root {
    --fixation-size: 144px;      /* 2× bigger cross for better visibility */
    --fixation-box-height: 180px;/* vertical space reserved under the title */
    --fixation-shift: 22px;      /* push cross down to visually center between title & UI */
}
body {
    font-family: Arial, sans-serif;
    background: #111;
    color: #eee;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    margin: 0;
}
#app {
    width: 780px;
    background: #1e1e1e;
    padding: 24px;
    border-radius: 12px;
    box-shadow: 0 0 20px rgba(0,0,0,0.5);
    text-align: center;
}
button {
    padding: 12px 20px;
    margin: 10px;
    font-size: 16px;
    border-radius: 8px;
    border: none;
    cursor: pointer;
    transition: background-color 100ms ease, transform 40ms ease;
}
#matchBtn { background: #4caf50; color: #000; }
#matchBtn.flash { background: #7fff7f !important; }
#backBtn, #homeBtn, .secondaryBtn { background: #9e9e9e; color: #000; }

.controls {
    display: inline-flex;
    gap: 12px;
    align-items: center;
    margin-bottom: 12px;
    background: #252525;
    padding: 10px 12px;
    border-radius: 8px;
    flex-wrap: wrap;
    justify-content: center;
}
label { color: #ddd; font-size: 14px; }
select {
    padding: 6px 8px;
    font-size: 14px;
    border-radius: 6px;
    border: 1px solid #444;
    background: #1b1b1b;
    color: #eee;
}

/* Fixation cross under title */
#topFixationWrap {
    height: var(--fixation-box-height);
    display: flex;
    align-items: flex-start;
    justify-content: center;
    margin: 6px 0 10px;
}
#fixation {
    font-size: var(--fixation-size);
    line-height: 1;
    color: #bbb;
    margin-top: var(--fixation-shift);
}
.hidden { visibility: hidden; }

/* Stimulus-only area (for distractors in Cond 3 & 4) */
#stimulusArea {
    margin-top: 16px;
    height: 120px;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
}
#visualStimulus {
    font-size: 72px;
    line-height: 1;
    visibility: hidden; /* prevents layout jumps when toggling */
}

/* Results panel */
#results {
    text-align: left;
    margin-top: 20px;
    background: #2a2a2a;
    padding: 16px;
    border-radius: 8px;
    display: none;
}

/* Small helper text */
.small { color: #aaa; font-size: 12px; margin-top: 8px; }

/* Instructions page */
#instructions {
    display: none;
    text-align: left;
    background: #222;
    padding: 16px;
    border-radius: 10px;
}
#instructions h2 { text-align: center; margin-top: 0; }
.instruct-block {
    background: #2a2a2a;
    border: 1px solid #3a3a3a;
    padding: 12px;
    border-radius: 8px;
    margin: 10px 0;
}

/* Voice settings page */
#voiceSettings {
    display: none;
    text-align: left;
    background: #222;
    padding: 16px;
    border-radius: 10px;
}
#voiceSettings h2 { text-align: center; margin-top: 0; }
.setting-group {
    background: #2a2a2a;
    border: 1px solid #3a3a3a;
    padding: 12px;
    border-radius: 8px;
    margin: 10px 0;
}
.setting-row {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
    align-items: center;
    margin: 6px 0;
}
.setting-row label { min-width: 64px; }
.note { color: #bbb; font-size: 13px; margin: 6px 0 0 0; }
.testBtn { background: #2196f3; color: #000; }
</style>
</head>
<body>

<div id="app">
    <h1>Auditory N-Back Task</h1>

    <!-- Fixation cross (under title) -->
    <div id="topFixationWrap">
        <div id="fixation" class="hidden">+</div>
    </div>

    <!-- MENU (home screen) -->
    <div id="menu">
        <div class="controls">
            <label for="nSelect">N‑back:</label>
            <select id="nSelect" aria-label="Select N-back level">
                <option value="1">1‑back</option>
                <option value="2" selected>2‑back</option>
                <option value="3">3‑back</option>
            </select>

            <label for="isiSelect">ISI (ms):</label>
            <select id="isiSelect" aria-label="Select inter-stimulus interval">
                <option value="00">Slow (00)</option>
                <option value="2500">Moderate (2500)</option>
                <option value="2000" selected>Default (2000)</option>
                <option value="1500">Fast (1500)</option>
                <option value="1000">Very Fast (1000)</option>
            </select>
        </div>

        <p>Select Condition</p>
        <div>
            <button type="button" onclick="startExperiment(1)">Condition 1: Letters</button>
            <button type="button" onclick="startExperiment(2)">Condition 2: Sounds</button>
        </div>
        <div>
            <button type="button" onclick="startExperiment(3)">Letters + Visual Distractor</button>
            <button type="button" onclick="startExperiment(4)">Sounds + Visual Distractor</button>
        </div>

        <!-- Buttons for other pages -->
        <div>
            <button type="button" class="secondaryBtn" onclick="showInstructions()">Instructions</button>
            <button type="button" class="secondaryBtn" onclick="showVoiceSettings()">Audio/Voice Settings</button>
        </div>

        <p class="small">Tip: Space/Enter activates MATCH once the task begins.</p>
    </div>

    <!-- TASK (run screen) -->
    <div id="task" style="display:none;">
        <div style="display:flex; align-items:center; gap:12px; justify-content:flex-start;">
            <button id="backBtn" type="button" onclick="backToMenu()" aria-label="Back to menu">← Back</button>
        </div>

        <h2 id="conditionLabel"></h2>
        <p>
            N‑back level: <span id="nLevel">2</span>
            &nbsp;|&nbsp; ISI: <span id="isiLabel">2000</span> ms
        </p>

        <button id="matchBtn" type="button" aria-label="Match (press Space or Enter)">MATCH</button>

        <div id="stimulusArea">
            <div id="visualStimulus"></div>
        </div>

        <div id="status"></div>
    </div>

    <!-- RESULTS -->
    <div id="results"></div>

    <!-- INSTRUCTIONS PAGE -->
    <div id="instructions">
        <h2>Instructions</h2>

        <div class="instruct-block">
            <h3>General (N‑Back Rule)</h3>
            <ul>
                <li>You will hear a sequence of items (letters or tones), one at a time.</li>
                <li>Press <b>MATCH</b> if the current item is the same as the one from <b>N steps back</b>.</li>
                <li>Example (2‑back): If the current item matches the one two items ago, press <b>MATCH</b>.</li>
                <li>Respond during the current item’s window; late presses don’t count for the prior trial.</li>
                <li>Change difficulty (N‑back) and speed (ISI) on the home screen.</li>
            </ul>
        </div>

        <div class="instruct-block">
            <h3>Condition 1: Letters</h3>
            <ul>
                <li>You will hear <b>spoken letters</b> (A–Z).</li>
                <li>Press <b>MATCH</b> if the letter matches the letter from N items ago.</li>
                <li>Tip: If letters are hard to hear, adjust the <b>Audio/Voice Settings</b> on the home screen.</li>
            </ul>
        </div>

        <div class="instruct-block">
            <h3>Condition 2: Sounds</h3>
            <ul>
                <li>You will hear <b>tones</b> (different pitches).</li>
                <li>Press <b>MATCH</b> if the current tone matches the tone from N items ago.</li>
            </ul>
        </div>

        <div class="instruct-block">
            <h3>Condition 3: Letters + Visual Distractor</h3>
            <ul>
                <li>You will hear <b>spoken letters</b> as in Condition 1.</li>
                <li>During each item, a <b>visual symbol</b> briefly appears below the fixation cross.</li>
                <li><b>Ignore</b> the symbol; it’s a distractor. Focus on the letters and the N‑back rule.</li>
            </ul>
        </div>

        <div class="instruct-block">
            <h3>Condition 4: Sounds + Visual Distractor</h3>
            <ul>
                <li>You will hear <b>tones</b> as in Condition 2.</li>
                <li>During each item, a <b>visual symbol</b> briefly appears below the fixation cross.</li>
                <li><b>Ignore</b> the symbol; it’s a distractor. Focus on the tones and the N‑back rule.</li>
            </ul>
        </div>

        <div style="text-align:center; margin-top: 12px;">
            <button id="homeBtn" type="button" onclick="backToHomeFromInstructions()">← Back to Home</button>
        </div>
    </div>

    <!-- VOICE SETTINGS PAGE -->
    <div id="voiceSettings">
        <h2>Audio/Voice Settings</h2>

        <div class="setting-group">
            <h3>What these settings do</h3>
            <ul>
                <li><b>Voice</b>: The speaker used for letters. Pick a natural, clear voice.</li>
                <li><b>Rate</b>: Speaking speed. Slightly slower (e.g., 0.9) improves single‑letter clarity.</li>
                <li><b>Pitch</b>: High/low quality of the voice. Near 1.0 is most natural; slightly lower can help clarity.</li>
                <li><b>Volume</b>: Loudness (1.0 is full volume).</li>
            </ul>
            <p class="note">Tip: After changing settings, press <b>Test voice (Sample audio)</b> to hear the result.</p>
        </div>

        <div class="setting-group">
            <div class="setting-row">
                <label for="voiceSelect">Voice:</label>
                <select id="voiceSelect" aria-label="Select TTS voice">
                    <option value="">Auto (best available)</option>
                </select>
            </div>

            <div class="setting-row">
                <label for="ttsRate">Rate:</label>
                <select id="ttsRate" aria-label="TTS rate">
                    <option value="0.8">0.8</option>
                    <option value="0.9" selected>0.9</option>
                    <option value="1.0">1.0</option>
                    <option value="1.1">1.1</option>
                </select>
            </div>

            <div class="setting-row">
                <label for="ttsPitch">Pitch:</label>
                <select id="ttsPitch" aria-label="TTS pitch">
                    <option value="0.9">0.9</option>
                    <option value="1.0" selected>1.0</option>
                    <option value="1.1">1.1</option>
                </select>
            </div>

            <div class="setting-row">
                <label for="ttsVol">Volume:</label>
                <select id="ttsVol" aria-label="TTS volume">
                    <option value="0.8">0.8</option>
                    <option value="1.0" selected>1.0</option>
                </select>
            </div>

            <div class="setting-row" style="justify-content:center;">
                <button type="button" class="testBtn" onclick="testTtsSample()">Test voice (Sample audio)</button>
            </div>
        </div>

        <div style="text-align:center; margin-top: 12px;">
            <button type="button" class="secondaryBtn" onclick="backToHomeFromVoice()">← Back to Home</button>
        </div>
    </div>
</div>

<script>
/* ────────────────────────────────────────────────────────────────────────────
   GLOBALS & CONSTANTS (core behavior)
   ──────────────────────────────────────────────────────────────────────────── */
let condition = 1, n = 2, sequence = [], index = 0, trialActive = false;
let results = [];
let trialStartTime = null;
let isi = 2000, trials = 40;
const stimDur = 600; // visual distractor duration in ms (conditions 3 & 4)

let runActive = false, trialTimeoutId = null, distractorTimeoutId = null;

const ctx = new (window.AudioContext || window.webkitAudioContext)();
const LETTERS = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
const TONES = [300, 450, 600, 750, 900];
const DISTRACTORS = ["▲", "■", "●", "★", "☀", "☂", "◆"];

const matchBtn = document.getElementById("matchBtn");
const nSelect = document.getElementById("nSelect");
const isiSelect = document.getElementById("isiSelect");
const visualBox = document.getElementById("visualStimulus");
const fixation = document.getElementById("fixation");

// Pages
const menuEl = document.getElementById("menu");
const taskEl = document.getElementById("task");
const resultsEl = document.getElementById("results");
const instructionsEl = document.getElementById("instructions");
const voiceSettingsEl = document.getElementById("voiceSettings");

// TTS controls & state
const voiceSelect = document.getElementById('voiceSelect');
const ttsRateSel  = document.getElementById('ttsRate');
const ttsPitchSel = document.getElementById('ttsPitch');
const ttsVolSel   = document.getElementById('ttsVol');
let availableVoices = [];

/* ────────────────────────────────────────────────────────────────────────────
   CONTROLLED TARGET POLICY (evenness guardrails)
   - targetRatioByN / overrideRatio: overall density
   - windows: distribute targets across windows (~evenness across time)
   - streak controls: cap long streaks; guarantee some singles; spacing between streaks
   - long gap: at least one no-target span of length in [min,max]
   ──────────────────────────────────────────────────────────────────────────── */
const TARGET_POLICY = {
  targetRatioByN: { 1: 0.30, 2: 0.40, 3: 0.30 }, // typical baseline
  overrideRatio: null,           // e.g., 0.40 → ~12 targets in 30; null = use table above
  windows: 3,                    // split [n..end] into W windows for distribution
  windowTolerance: 1,            // allow ±1 deviation from computed window quota
  minSinglesRatio: 0.55,         // ≥55% of targets must be singles
  streakTrialRatio: 0.15,        // ≈15% of *trials* involved in streaks
  allowLengths: [2,3],         // streak lengths allowed
  maxByLength: { 3: 1, 2: 3 },   // cap: ≤1 three‑in‑a‑row and ≤3 two‑in‑a‑row
  maxConsecutiveTargets: 3,      // hard cap on streak length in final layout
  minSpacingBetweenStreaks: 6,   // aim for ≥6 non‑targets between streak groups
  gapSpanLengthRange: [6, 8]    // at least one long gap (no targets)
};

/* ────────────────────────────────────────────────────────────────────────────
   NAVIGATION HELPERS
   ──────────────────────────────────────────────────────────────────────────── */
function hideAllPages() {
    menuEl.style.display = "none";
    taskEl.style.display = "none";
    resultsEl.style.display = "none";
    instructionsEl.style.display = "none";
    voiceSettingsEl.style.display = "none";
}
function showInstructions() {
    hideAllPages();
    fixation.classList.add("hidden");
    instructionsEl.style.display = "block";
}
function backToHomeFromInstructions() {
    hideAllPages();
    menuEl.style.display = "block";
    fixation.classList.add("hidden");
}
function showVoiceSettings() {
    hideAllPages();
    fixation.classList.add("hidden");
    if (!availableVoices.length) populateVoices();
    voiceSettingsEl.style.display = "block";
}
function backToHomeFromVoice() {
    hideAllPages();
    menuEl.style.display = "block";
    fixation.classList.add("hidden");
}

/* ────────────────────────────────────────────────────────────────────────────
   PERSISTENCE (localStorage) for TTS settings
   ──────────────────────────────────────────────────────────────────────────── */
const TTS_STORAGE_KEY = 'ttsSettings_v1';
function saveTtsSettings() {
    try {
        const data = {
            voiceName: voiceSelect.value || '',
            rate: String(ttsRateSel.value || ''),
            pitch: String(ttsPitchSel.value || ''),
            volume: String(ttsVolSel.value || '')
        };
        localStorage.setItem(TTS_STORAGE_KEY, JSON.stringify(data));
    } catch (e) { console.warn('Could not save TTS settings:', e); }
}
function loadTtsSettings() {
    try {
        const raw = localStorage.getItem(TTS_STORAGE_KEY);
        if (!raw) return;
        const data = JSON.parse(raw);
        if (data && typeof data === 'object') {
            if (data.rate)  ttsRateSel.value  = String(data.rate);
            if (data.pitch) ttsPitchSel.value = String(data.pitch);
            if (data.volume)ttsVolSel.value   = String(data.volume);
            if (typeof data.voiceName === 'string') voiceSelect.dataset.desiredVoice = data.voiceName;
        }
    } catch (e) { console.warn('Could not load TTS settings:', e); }
}
loadTtsSettings();
[voiceSelect, ttsRateSel, ttsPitchSel, ttsVolSel].forEach(el => el.addEventListener('change', saveTtsSettings));

/* ────────────────────────────────────────────────────────────────────────────
   TTS VOICES
   ──────────────────────────────────────────────────────────────────────────── */
function populateVoices() {
    availableVoices = window.speechSynthesis.getVoices() || [];
    voiceSelect.innerHTML = '<option value="">Auto (best available)</option>';
    availableVoices.forEach(v => {
        const opt = document.createElement('option');
        opt.value = v.name;
        opt.textContent = `${v.name} — ${v.lang}`;
        voiceSelect.appendChild(opt);
    });
    const desired = voiceSelect.dataset.desiredVoice;
    if (desired) {
        const foundDesired = availableVoices.find(v => v.name === desired);
        if (foundDesired) { voiceSelect.value = foundDesired.name; delete voiceSelect.dataset.desiredVoice; return; }
    }
    const preferredNames = [
        'Microsoft Aria Online (Natural) - English (United States)',
        'Microsoft Jenny Online (Natural) - English (United States)',
        'Microsoft Guy Online (Natural) - English (United States)',
        'Microsoft Samantha Online (Natural) - English (United States)',
        'Samantha','Ava','Alex',
        'Google US English','Google UK English Female','Google UK English Male'
    ];
    for (const name of preferredNames) {
        const found = availableVoices.find(v => v.name === name);
        if (found) { voiceSelect.value = found.name; return; }
    }
    if (!voiceSelect.value) {
        const en = availableVoices.find(v => (v.lang || '').toLowerCase().startsWith('en'));
        if (en) voiceSelect.value = en.name;
    }
}
window.speechSynthesis.onvoiceschanged = populateVoices;
populateVoices();

/* ────────────────────────────────────────────────────────────────────────────
   TTS SAMPLE TEST (on Voice Settings page)
   ──────────────────────────────────────────────────────────────────────────── */
function testTtsSample() {
    const utter = new SpeechSynthesisUtterance('Sample audio');
    const rate  = parseFloat(ttsRateSel.value || '0.9');
    const pitch = parseFloat(ttsPitchSel.value || '1.0');
    const vol   = parseFloat(ttsVolSel.value   || '1.0');
    utter.rate   = isNaN(rate)  ? 0.9 : rate;
    utter.pitch  = isNaN(pitch) ? 1.0 : pitch;
    utter.volume = isNaN(vol)   ? 1.0 : vol;
    const chosen = availableVoices.find(v => v.name === voiceSelect.value);
    if (chosen) { utter.voice = chosen; if (chosen.lang) utter.lang = chosen.lang; }
    else { const en = availableVoices.find(v => (v.lang || '').toLowerCase().startsWith('en')); if (en) { utter.voice = en; if (en.lang) utter.lang = en.lang; } }
    window.speechSynthesis.cancel();
    window.speechSynthesis.speak(utter);
}

/* ────────────────────────────────────────────────────────────────────────────
   MATCH BUTTON FEEDBACK & KEYBOARD (scoped)
   ──────────────────────────────────────────────────────────────────────────── */
function flashMatchButton() {
    matchBtn.classList.add("flash");
    setTimeout(() => matchBtn.classList.remove("flash"), 120);
}
matchBtn.addEventListener("click", () => { flashMatchButton(); registerResponse(); });
matchBtn.addEventListener("keydown", (e) => {
    if (e.code === "Space" || e.code === "Enter") { e.preventDefault(); flashMatchButton(); registerResponse(); }
});

/* ────────────────────────────────────────────────────────────────────────────
   START EXPERIMENT
   - Uses the controlled sequence generator below.
   ──────────────────────────────────────────────────────────────────────────── */
function startExperiment(cond) {
    if (!availableVoices.length) { populateVoices(); setTimeout(()=>{},0); }

    n = parseInt(nSelect.value, 10); if (isNaN(n) || n < 1) n = 1;
    isi = parseInt(isiSelect.value, 10); if (isNaN(isi) || isi < 500) isi = 500;

    document.getElementById("nLevel").textContent = n;
    document.getElementById("isiLabel").textContent = isi;

    condition = cond;
    hideAllPages();
    taskEl.style.display = "block";

    document.getElementById("conditionLabel").textContent =
        "Condition " + cond + (cond <= 2 ? "" : " (with visual distractor)");

    trials = 40; // change if you want longer blocks

    const pool = (condition === 1 || condition === 3) ? LETTERS : TONES;

    // *** Controlled sequence generation (evenness edition) ***
    sequence = buildControlledSequence(trials, n, pool, TARGET_POLICY);

    // Reset run state
    index = 0;
    results = [];
    runActive = true;
    trialActive = false;
    clearTimeout(trialTimeoutId);
    clearTimeout(distractorTimeoutId);
    window.speechSynthesis.cancel();

    fixation.classList.remove("hidden");
    visualBox.style.visibility = "hidden";
    visualBox.textContent = "";

    nextTrial();
}

/* ────────────────────────────────────────────────────────────────────────────
   AUDIO HELPERS
   ──────────────────────────────────────────────────────────────────────────── */
function playTone(freq) {
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    const now = ctx.currentTime;

    osc.frequency.value = freq;

    // Fade in/out to avoid clicks
    gain.gain.setValueAtTime(0, now);
    gain.gain.linearRampToValueAtTime(0.22, now + 0.02);
    gain.gain.linearRampToValueAtTime(0.22, now + 0.35);
    gain.gain.linearRampToValueAtTime(0, now + 0.4);

    osc.connect(gain);
    gain.connect(ctx.destination);

    osc.start(now);
    osc.stop(now + 0.42);
}
function speakLetter(letter) {
    const utter = new SpeechSynthesisUtterance(letter);
    const rate  = parseFloat(ttsRateSel.value || '0.9');
    const pitch = parseFloat(ttsPitchSel.value || '1.0');
    const vol   = parseFloat(ttsVolSel.value   || '1.0');
    utter.rate   = isNaN(rate)  ? 0.9 : rate;
    utter.pitch  = isNaN(pitch) ? 1.0 : pitch;
    utter.volume = isNaN(vol)   ? 1.0 : vol;
    const chosen = availableVoices.find(v => v.name === voiceSelect.value);
    if (chosen) { utter.voice = chosen; if (chosen.lang) utter.lang = chosen.lang; }
    else { const en = availableVoices.find(v => (v.lang || '').toLowerCase().startsWith('en')); if (en) { utter.voice = en; if (en.lang) utter.lang = en.lang; } }
    window.speechSynthesis.cancel();
    window.speechSynthesis.speak(utter);
}

/* ────────────────────────────────────────────────────────────────────────────
   BACK TO MENU (during a run)
   ──────────────────────────────────────────────────────────────────────────── */
function backToMenu() {
    runActive = false; trialActive = false;
    clearTimeout(trialTimeoutId); clearTimeout(distractorTimeoutId);
    window.speechSynthesis.cancel();

    hideAllPages();
    menuEl.style.display = "block";

    fixation.classList.add("hidden");
    visualBox.style.visibility = "hidden";
    visualBox.textContent = "";
}

/* ────────────────────────────────────────────────────────────────────────────
   TRIAL LOOP & INPUT
   ──────────────────────────────────────────────────────────────────────────── */
function nextTrial() {
    if (!runActive) return;
    if (index >= sequence.length) { endExperiment(); return; }

    trialActive = true;
    const stim = sequence[index];

    // Visual distractor (Cond 3/4): hide fixation briefly and show symbol
    if (condition === 3 || condition === 4) {
        fixation.classList.add("hidden");
        visualBox.textContent = DISTRACTORS[Math.floor(Math.random() * DISTRACTORS.length)];
        visualBox.style.visibility = "visible";
        clearTimeout(distractorTimeoutId);
        distractorTimeoutId = setTimeout(() => {
            visualBox.style.visibility = "hidden";
            visualBox.textContent = "";
            fixation.classList.remove("hidden");
        }, stimDur);
    } else {
        fixation.classList.remove("hidden");
        visualBox.style.visibility = "hidden";
        visualBox.textContent = "";
    }

    // Present auditory stimulus
    if (condition === 1 || condition === 3) speakLetter(stim);
    else playTone(stim);

    // Record trial state
    const isTarget = (index >= n && stim === sequence[index - n]);
    results.push({ stimulus: stim, target: isTarget, responded: false, rt: null });

    // Start RT timer
    trialStartTime = performance.now();

    // Advance after ISI
    clearTimeout(trialTimeoutId);
    trialTimeoutId = setTimeout(() => {
        if (!runActive) return;
        index++;
        trialActive = false;
        nextTrial();
    }, isi);
}
function registerResponse() {
    if (!trialActive || !runActive) return;
    if (index < 0 || index >= results.length) return;
    const r = results[index];
    if (!r || r.responded) return;
    r.responded = true;
    r.rt = performance.now() - (trialStartTime ?? performance.now());
}

/* ────────────────────────────────────────────────────────────────────────────
   END EXPERIMENT
   ──────────────────────────────────────────────────────────────────────────── */
function endExperiment() {
    if (!runActive) return;
    runActive = false;

    hideAllPages();
    resultsEl.style.display = "block";

    let hits = 0, misses = 0, falseAlarms = 0;
    results.forEach(r => {
        if (r.target && r.responded) hits++;
        if (r.target && !r.responded) misses++;
        if (!r.target && r.responded) falseAlarms++;
    });
    const rts = results.filter(r => r.responded && typeof r.rt === "number").map(r => r.rt);
    const meanRT = rts.length ? Math.round(rts.reduce((a,b)=>a+b,0)/rts.length) : "—";

    resultsEl.innerHTML = `
        <h3>Results</h3>
        <p><b>N‑back:</b> ${n}</p>
        <p><b>ISI:</b> ${isi} ms</p>
        <p><b>Trials:</b> ${sequence.length}</p>
        <p><b>Hits:</b> ${hits}</p>
        <p><b>Misses:</b> ${misses}</p>
        <p><b>False Alarms:</b> ${falseAlarms}</p>
        <p><b>Mean Reaction Time:</b> ${meanRT} ms</p>
        <button onclick="location.reload()">Restart</button>
        <button onclick="backToMenu()">Back to Menu</button>
    `;
}

/* ────────────────────────────────────────────────────────────────────────────
   *** CONTROLLED SEQUENCE ENGINE (EVENNESS EDITION) ***
   See header comments for design goals and constraints.
   ──────────────────────────────────────────────────────────────────────────── */
function buildControlledSequence(trials, n, pool, policy) {
  const randInt = (a,b) => Math.floor(Math.random()*(b-a+1))+a; // inclusive
  const pick = (arr) => arr[Math.floor(Math.random()*arr.length)];
  const shuffle = (arr) => arr.sort(()=>Math.random()-0.5);
  const notEqFromPool = (pool, forbid) => {
    const cands = pool.filter(x => x !== forbid);
    return pick(cands.length ? cands : pool);
  };

  if (trials <= 0) return [];
  if (n < 0) n = 0;
  const validStart = Math.min(n, trials);
  const validEnd   = trials - 1;
  const validCount = Math.max(0, trials - n);

  const baseRatio = (policy.overrideRatio != null)
    ? policy.overrideRatio
    : (policy.targetRatioByN[n] ?? 0.30);
  let desiredTargets = Math.round(baseRatio * trials);
  desiredTargets = Math.min(desiredTargets, validCount);
  if (desiredTargets === 0 && validCount > 0) desiredTargets = 1;

  // Long no‑target gap
  const [gapMin, gapMax] = policy.gapSpanLengthRange || [8,10];
  const gapLen = Math.min(randInt(gapMin, gapMax), validCount);
  const gapStart = (validCount > gapLen) ? (validStart + randInt(0, validCount - gapLen)) : validStart;
  const gapIndices = new Set();
  for (let i = gapStart; i < gapStart + gapLen; i++) gapIndices.add(i);

  // Windowing (spread targets)
  const W = Math.max(1, policy.windows || 1);
  const winBounds = [];
  const span = validEnd - validStart + 1;
  for (let w=0; w<W; w++) {
    const s = validStart + Math.floor(w*span/W);
    const e = validStart + Math.floor((w+1)*span/W) - 1;
    winBounds.push([s, e]);
  }
  const winSlots = winBounds.map(([s,e]) => {
    let nSlots = 0;
    for (let i=s;i<=e;i++) if (!gapIndices.has(i)) nSlots++;
    return nSlots;
  });
  const totalFreeSlots = winSlots.reduce((a,b)=>a+b,0);
  let winTarget = winSlots.map(ns => Math.round((ns/Math.max(1,totalFreeSlots))*desiredTargets));
  let diff = desiredTargets - winTarget.reduce((a,b)=>a+b,0);
  while (diff !== 0) {
    const idx = (diff>0)
      ? winSlots.indexOf(Math.max(...winSlots))
      : winTarget.indexOf(Math.max(...winTarget));
    if (idx === -1) break;
    winTarget[idx] += (diff>0 ? 1 : -1);
    diff = desiredTargets - winTarget.reduce((a,b)=>a+b,0);
  }
  const tol = Math.max(0, policy.windowTolerance ?? 0);

  // Streak composition
  const minSingles = Math.ceil((policy.minSinglesRatio ?? 0.35) * desiredTargets);
  let streakBudget = Math.min(
    Math.max(0, Math.round((policy.streakTrialRatio ?? 0.15) * trials)),
    desiredTargets - minSingles
  );
  const allowL = (policy.allowLengths || [2,3,4]).slice().sort((a,b)=>b-a);
  const maxByL = policy.maxByLength || {4:1,3:2};
  const streaks = [];
  for (const L of allowL) {
    const cap = Math.max(0, maxByL[L] ?? Infinity);
    for (let k=0; k<cap && streakBudget >= L; k++) {
      streaks.push(L);
      streakBudget -= L;
    }
  }
  while (streakBudget >= 2) { streaks.push(2); streakBudget -= 2; }

  const streakTargetCount = streaks.reduce((a,b)=>a+b,0);
  let singlesCount = Math.max(0, desiredTargets - streakTargetCount);
  while (singlesCount < minSingles && streaks.length) {
    const L = streaks.pop();
    singlesCount += L;
  }

  const chosen = new Set();
  const maxLenCap = Math.max(1, policy.maxConsecutiveTargets || 4);

  function canPlaceStreak(idx, L, wIdx) {
    const [ws, we] = winBounds[wIdx];
    for (let k=0;k<L;k++) {
      const pos = idx + k;
      if (pos < ws || pos > we) return false;
      if (gapIndices.has(pos)) return false;
      if (chosen.has(pos)) return false;
      if (pos < validStart) return false;
    }
    const pad = Math.max(0, policy.minSpacingBetweenStreaks ?? 0);
    for (let p = idx - pad; p <= idx + L - 1 + pad; p++) {
      if (p < ws || p > we) continue;
      if (p >= idx && p <= idx+L-1) continue;
      if (chosen.has(p)) return false;
    }
    return true;
  }

  const winRemain = winTarget.slice();
  const streaksShuffled = shuffle(streaks.slice());
  for (let sIdx=0; sIdx<streaksShuffled.length; sIdx++) {
    const L = Math.min(streaksShuffled[sIdx], maxLenCap);
    let placed = false;
    for (let pass=0; pass<2 && !placed; pass++) {
      for (let w=0; w<winBounds.length && !placed; w++) {
        const [ws, we] = winBounds[w];
        if (winRemain[w] < Math.max(0, L - tol)) continue;
        const candidates = [];
        for (let start = ws; start <= we - L + 1; start++) {
          let ok = true;
          for (let k=0;k<L;k++) {
            const pos = start+k;
            if (gapIndices.has(pos) || pos < validStart) { ok=false; break; }
          }
          if (ok) candidates.push(start);
        }
        shuffle(candidates);
        for (const start of candidates) {
          if (!canPlaceStreak(start, L, w)) continue;
          for (let k=0;k<L;k++) chosen.add(start+k);
          winRemain[w] = Math.max(0, winRemain[w] - L);
          placed = true;
          break;
        }
      }
    }
    if (!placed) {
      outer:
      for (let w=0; w<winBounds.length; w++) {
        const [ws,we] = winBounds[w];
        for (let start = ws; start <= we - L + 1; start++) {
          let ok = true;
          for (let k=0;k<L;k++) {
            const pos = start+k;
            if (gapIndices.has(pos) || chosen.has(pos) || pos < validStart) { ok=false; break; }
          }
          if (ok) {
            for (let k=0;k<L;k++) chosen.add(start+k);
            winRemain[w] = Math.max(0, winRemain[w] - L);
            placed = true;
            break outer;
          }
        }
      }
    }
    if (!placed) singlesCount += L;
  }

  function freeSlotsInWindow(w) {
    const [ws,we] = winBounds[w];
    const arr = [];
    for (let i=ws;i<=we;i++) {
      if (i >= validStart && !gapIndices.has(i) && !chosen.has(i)) arr.push(i);
    }
    return arr;
  }
  for (let w=0; w<winBounds.length && singlesCount>0; w++) {
    let need = Math.max(0, winRemain[w]);
    let pool = freeSlotsInWindow(w);
    shuffle(pool);
    while (need>0 && pool.length && singlesCount>0) {
      const pos = pool.pop();
      chosen.add(pos);
      need--; singlesCount--;
    }
    winRemain[w] = Math.max(0, need);
  }
  if (singlesCount > 0) {
    let allFree = [];
    for (let w=0; w<winBounds.length; w++) allFree = allFree.concat(freeSlotsInWindow(w));
    allFree = allFree.filter(i => !chosen.has(i));
    shuffle(allFree);
    while (singlesCount>0 && allFree.length) {
      chosen.add(allFree.pop());
      singlesCount--;
    }
  }

  let currentTargets = chosen.size;
  if (currentTargets < desiredTargets) {
    const spare = [];
    for (let i=validStart;i<=validEnd;i++) {
      if (!gapIndices.has(i) && !chosen.has(i)) spare.push(i);
    }
    shuffle(spare);
    while (currentTargets < desiredTargets && spare.length) {
      chosen.add(spare.pop());
      currentTargets++;
    }
  }
  if (currentTargets > desiredTargets) {
    const allChosen = Array.from(chosen).sort((a,b)=>a-b);
    while (chosen.size > desiredTargets && allChosen.length) {
      chosen.delete(allChosen.pop());
    }
  }

  const seq = new Array(trials).fill(null);
  for (let i=0; i<Math.min(n,trials); i++) seq[i] = pick(pool);
  for (let i=n; i<trials; i++) {
    const isTarget = chosen.has(i);
    if (isTarget) seq[i] = seq[i - n];
    else          seq[i] = notEqFromPool(pool, seq[i - n]);
  }

  const cap = Math.max(1, policy.maxConsecutiveTargets || 4);
  let run = 0;
  for (let i=validStart;i<trials;i++) {
    const isT = (i>=n && seq[i] === seq[i-n]);
    run = isT ? run+1 : 0;
    if (run > cap) {
      seq[i] = notEqFromPool(pool, seq[i - n]);
      run = 0;
    }
  }

  return seq;
}
</script>
</body>
</html>
